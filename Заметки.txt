Начало работы: 30.01.2024

Хедлайнер всех бед - подсветка кнопок во внутриигровом меню.
Уважаемая подсветка кнопок во внутриигровом меню, почему так косо?

Заметки по механикам игры:
    1. Сделать логику для игры.
    2. Изменить музыку под стилизованную. Добавить звуки столкновения
    3. Для окна финала - сделать отдельную сцену

Заметки внутриигровому меню:
    1.
    2. 
    3. Добавить раздел игра против компьютера
        3.1 Добавить кооператив
    4.
    5. Добавить вкл выкл музыки в настройках

Заметки по коду:
    1. Перенести некоторые переменные из gaim_main_menu.py  в config
    2. Как перенести кодификацию цветов и шрифты в config?
    3. Как поставить кастомный курсор?
    4. Куда деть характеристики окружности и прямоугольника?
    5. Куда вынести огромное количество переменных в файле game_main_menu.py ?
    6. pygame.error: display Surface quit - отработать
    
Заметки по лаунчеру:
    1. Запретить менять кнопки управления на  K_p и K_ESCAPE
    2. Переделать макет раздела настроек(зона с ползунком и внизу формы вне зоны с ползунком кнопка возврата в главное меню), далее:
        2.1 Откорректировать код заполнения раздела настройки и ошибки, которые появятся после этого
        2.2 В разделе настройки сделать окно с ползунком, чтобы не менять размер окна в зависимости от количества выводимой информации
    3. Вкл выкл музыки

Сохраненный на всякий пожарный код:
    self.setWindowFlags(Qt.FramelessWindowHint)  - окно без рамки
    game_screen = pygame.display.set_mode((screen_width, screen_height),pygame.NOFRAME):
        pygame.NOFRAME - убрать шапку у окна
    elif event.type == pygame.MOUSEMOTION:
            print("Позиция мыши: ", event.pos)
    код для паузы и эскейпа:
    1. железобетонно работает, но теряется возможность изменять клавиши для паузы и внутриигрового меню
            for event in pygame.event.get():
                if event.type ==pygame.KEYDOWN:
                    if event.key == pygame.K_p:    
                        if state == pause:
                            state= running
                        else:
                            state=pause
                    if event.key == pygame.K_ESCAPE:                      
                        if state == pause:
                            pass
                        else:
                            state=pause

    2. за семь залуп за гороховый суп
            for event in pygame.event.get():
                if event.type ==pygame.key.get_pressed():
                    if event.key == pygame.key.get_pressed()[input_dict.controls_get(config,config_path)['pause']]:    
                        if state == pause:
                            state= running
                        else:
                            state=pause
                    if event.key == pygame.K_ESCAPE:                      
                        if state == pause:
                            pass
                        else:
                            state=pause

    класс Settings железобетонно работающий (input_dict.input_map не существует, считывать из config)

    class Settings(QtWidgets.QMainWindow, settings.Ui_MainWindow):
        def __init__(self):
            super().__init__()
            self.setupUi(self)
            self.ingame_menu_close_button.clicked.connect(self.leave_to_main)
            #создать лейбл и кнопку для каждого ключа
            i=0
            for key in input_dict.input_map.keys():
                i+=10
                self.key_label = QLabel(f'{key}', self) 
                self.key_label.setObjectName(f'label_{key}')
                self.key_label.setGeometry(QtCore.QRect(30, 30+i*2, 60, 60))
                self.value_label = QLabel(f'{input_dict.input_map[key]}', self)
                self.value_label.setGeometry(QtCore.QRect(150, 30+i*2, 60, 60))
                self.value_label.setObjectName(f'label_{key}')
                self.key_input = QLineEdit(f'{input_dict.input_map[key]}', self)
                self.key_input.setGeometry(QtCore.QRect(200, 50+i*2, 80, 20))
                self.key_input.textChanged.connect(self.control_change)
                self.key_input.setObjectName(f'input_{key}')
                #self.key_button.clicked.connect(self.control_change)

        def control_change(self):
            self.key_button = QtWidgets.QPushButton('Подтвердить изменения',self)
            self.key_button.setGeometry(QtCore.QRect(self.key_input.x(), self.key_input.y()+20, 160, 30))
            self.key_button.clicked.connect(self.change_value)
            self.key_button.show()

        def change_value(self):
            for key in input_dict.input_map:
                input_dict.input_map[key]=self.findChild(QLineEdit, f"input_{key}").text()
            print(input_dict.input_map)