Сделать внутриигровое меню
Выводить внутриигровое меню при нажатии Escape(либо с помощью PyGame, либо Qt5)
Останавливать игру при открытии внутриигрового меню

При нажатии Escape в игре закрывается приложение

Вывод слова "Пауза", когда игра на паузе

Сделать возможность изменения управления:
    в launcher.py вместо controls_get() вставить проверку на заполненность config.ini
    внести все кнопки управления
    обработка ошибок
    импорт input_dict  в movement.py сильно битый


код для паузы и эскейпа:
1. железобетонно работает, но теряется возможность изменять клавиши для паузы и внутриигрового меню
        for event in pygame.event.get():
            if event.type ==pygame.KEYDOWN:
                if event.key == pygame.K_p:    
                    if state == pause:
                        state= running
                    else:
                        state=pause
                if event.key == pygame.K_ESCAPE:                      
                    if state == pause:
                        pass
                    else:
                        state=pause

2. за семь залуп за гороховый суп
        for event in pygame.event.get():
            if event.type ==pygame.key.get_pressed():
                if event.key == pygame.key.get_pressed()[input_dict.controls_get(config,config_path)['pause']]:    
                    if state == pause:
                        state= running
                    else:
                        state=pause
                if event.key == pygame.K_ESCAPE:                      
                    if state == pause:
                        pass
                    else:
                        state=pause

класс Settings железобетонно работающий (input_dict.input_map не существует, считывать из config)

class Settings(QtWidgets.QMainWindow, settings.Ui_MainWindow):
    def __init__(self):
        super().__init__()
        self.setupUi(self)
        self.ingame_menu_close_button.clicked.connect(self.leave_to_main)
        #создать лейбл и кнопку для каждого ключа
        i=0
        for key in input_dict.input_map.keys():
            i+=10
            self.key_label = QLabel(f'{key}', self) 
            self.key_label.setObjectName(f'label_{key}')
            self.key_label.setGeometry(QtCore.QRect(30, 30+i*2, 60, 60))
            self.value_label = QLabel(f'{input_dict.input_map[key]}', self)
            self.value_label.setGeometry(QtCore.QRect(150, 30+i*2, 60, 60))
            self.value_label.setObjectName(f'label_{key}')
            self.key_input = QLineEdit(f'{input_dict.input_map[key]}', self)
            self.key_input.setGeometry(QtCore.QRect(200, 50+i*2, 80, 20))
            self.key_input.textChanged.connect(self.control_change)
            self.key_input.setObjectName(f'input_{key}')
            #self.key_button.clicked.connect(self.control_change)

    def control_change(self):
        self.key_button = QtWidgets.QPushButton('Подтвердить изменения',self)
        self.key_button.setGeometry(QtCore.QRect(self.key_input.x(), self.key_input.y()+20, 160, 30))
        self.key_button.clicked.connect(self.change_value)
        self.key_button.show()

    def change_value(self):
        for key in input_dict.input_map:
            input_dict.input_map[key]=self.findChild(QLineEdit, f"input_{key}").text()
        print(input_dict.input_map)